<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gopal Oswal</title>
    <style>
        body{
            margin: 0;
        }
        #blocker {
			position: absolute;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.5);
		}

		#instructions {
			width: 100%;
			height: 100%;

			display: -webkit-box;
			display: -moz-box;
			display: box;

			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;

			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;

			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;

			color: #ffffff;
			text-align: center;
			font-family: Arial;
			font-size: 14px;
			line-height: 24px;

			cursor: pointer;
		}
    </style>
</head>
<body>
    <div id="blocker">
		<div id="instructions">
			<span style="font-size:36px">Click to play</span>
			<br /><br />
			Move: WASD<br/>
			Jump: SPACE<br/>
			Look: MOUSE
		</div>
	</div>
    <script src="js/three.min.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script>
        const objects = [];
        let raycaster;
        raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
        let prevTime = performance.now();
		const velocity = new THREE.Vector3();
		const direction = new THREE.Vector3();
		const vertex = new THREE.Vector3();
		const color = new THREE.Color();
        // creating a screne
        var scene = new THREE.Scene();
        // scene.background = new THREE.Color( 0xbcfbf7 );
        // creating a camera for view
        // fov — Camera frustum vertical field of view.
        // aspect — Camera frustum aspect ratio.
        // near — Camera frustum near plane.
        // far — Camera frustum far plane.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 10;
        
        // creating a renderer 
        var renderer = new THREE.WebGLRenderer(); 
        renderer.setSize(window.innerWidth, window.innerHeight);

        // added controls
        var controls =  new THREE.PointerLockControls( camera, document.body );
        const blocker = document.getElementById( 'blocker' );
		const instructions = document.getElementById( 'instructions' );

        instructions.addEventListener( 'click', function () {
			controls.lock();
		} );

		controls.addEventListener( 'lock', function () {
			instructions.style.display = 'none';
			blocker.style.display = 'none';
		} );

		controls.addEventListener( 'unlock', function () {
			blocker.style.display = 'block';
			instructions.style.display = '';
		} );
        scene.add( controls.getObject() );

        // ================================================================ FLOOR START ================================================================

        // adding floor 
        // width — Width along the X axis. Default is 1.
        // height — Height along the Y axis. Default is 1.
        // widthSegments — Optional. Default is 1.
        // heightSegments — Optional. Default is 1.
        var floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        floorGeometry.rotateX( - Math.PI / 2 );

        // vertex displacement
        let position = floorGeometry.attributes.position;
        for ( let i = 0, l = position.count; i < l; i ++ ) {

            vertex.fromBufferAttribute( position, i );

            vertex.x += Math.random() * 20 - 10;
            vertex.y += Math.random() * 2;
            vertex.z += Math.random() * 20 - 10;

            position.setXYZ( i, vertex.x, vertex.y, vertex.z );

        }

        floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

        position = floorGeometry.attributes.position;
        const colorsFloor = [];

        for ( let i = 0, l = position.count; i < l; i ++ ) {
            const obj1 = {
                c1: 30/100,
                c2: 10/100,
                c3: 35/100
            };
            const obj2 = {
                c1: 30/100,
                c2: 10/100,
                c3: 29/ 100
            };
            const obj3 = {
                c1: 30/100,
                c2: 10/100,
                c3: 23/100
            };
            // color.setHSL( Math.random() * 120 + 0.5, 100, Math.random() * 0.25 + 0.75 );
            if (i % 3 == 0) {
                color.setHSL(obj1.c1, obj1.c2, obj1.c3 );
                // console.log(0);
            } else if (i % 3 == 1) {
                color.setHSL(obj2.c1, obj2.c2, obj2.c3 );
                // console.log(1);
            } else if (i % 3 == 2) {
                color.setHSL(obj3.c1, obj3.c2, obj3.c3 );
                // console.log(2);
            } else {
                color.setHSL(obj3.c1, obj3.c2, obj3.c3 );
                // console.log(4);
            }
            // color.setHSL(c1, c2, c3 );
            colorsFloor.push( color.r, color.g, color.b );

        }

        floorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorsFloor, 3 ) );

        const floorMaterial = new THREE.MeshBasicMaterial( {vertexColors: true} );
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        scene.add(floor);

        // ================================================================ FLOOR END ================================================================

        // ================================================================ SKY STARTS ================================================================
        var skyGeo = new THREE.SphereGeometry(100000, 25, 25); 
        var loader  = new THREE.TextureLoader(),
        texture = loader.load( "img/sky.jpeg" );
        var material = new THREE.MeshPhongMaterial({ map: texture,});
        var sky = new THREE.Mesh(skyGeo, material);
        sky.material.side = THREE.BackSide;
        scene.add(sky);
        // ================================================================ SKY END ================================================================

        // ================================================================ TEXT START ================================================================
        const textLoader = new THREE.FontLoader();
		textLoader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {

        const textGeo = new THREE.TextGeometry( "THREE.JS", {
            font: font,
            size: 200,
            height: 50,
            curveSegments: 12,
            bevelThickness: 2,
            bevelSize: 5,
            bevelEnabled: true
        } 
        );

        textGeo.computeBoundingBox();
        // const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

        const textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff } );

        const mesh = new THREE.Mesh( textGeo, textMaterial );
        mesh.position.x = 0;
        mesh.position.y = 67;

        mesh.castShadow = true;
        mesh.receiveShadow = true;

        scene.add( mesh );

        } );

        // ================================================================ TEXT END ================================================================
        const planeMaterial = new THREE.MeshBasicMaterial( { color: 0xfffff } );
        const cubes1 = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), planeMaterial );
				cubes1.position.x = 50;
				cubes1.position.y = 0;
				cubes1.position.z = 0;
				// cubes1.castShadow = true;
				// cubes1.receiveShadow = true;
				scene.add( cubes1 );
                camera.position.z = 5;


        // rendering to html 
        renderer.render( scene, camera );
        document.body.appendChild( renderer.domElement );
        animate();
        function animate() {
            requestAnimationFrame( animate );

            const time = performance.now();

            if ( controls.isLocked === true ) {

                raycaster.ray.origin.copy( controls.getObject().position );
                raycaster.ray.origin.y -= 10;

                const intersections = raycaster.intersectObjects( objects );

                const onObject = intersections.length > 0;

                const delta = ( time - prevTime ) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                // direction.z = Number( moveForward ) - Number( moveBackward );
                // direction.x = Number( moveRight ) - Number( moveLeft );
                direction.normalize(); // this ensures consistent movements in all directions

                // if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
                // if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

                if ( onObject === true ) {

                    velocity.y = Math.max( 0, velocity.y );
                    canJump = true;

                }

                controls.moveRight( - velocity.x * delta );
                controls.moveForward( - velocity.z * delta );

                controls.getObject().position.y += ( velocity.y * delta ); // new behavior

                if ( controls.getObject().position.y < 10 ) {

                    velocity.y = 0;
                    controls.getObject().position.y = 10;

                    canJump = true;

                }

            }

            prevTime = time;

            renderer.render( scene, camera );

            }
    </script>
</body>
</html>